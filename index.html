
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
<title>Colab äº’å‹•å†’éšªï¼ˆv2ï¼šJSON å®‰å…¨åŒ¯å…¥ + æ¸…ç©ºå­˜æª”ï¼‰</title>
<style>
  html, body { margin:0; padding:0; background:#0e0f14; color:#e6e6ea; font-family: ui-sans-serif, system-ui, -apple-system, "PingFang TC","Noto Sans TC", Arial; }
  #app { display:grid; grid-template-columns: 1fr 320px; gap:10px; padding:10px; box-sizing:border-box; }
  #left { position:relative; }
  canvas { background:#12131a; border:1px solid #262837; border-radius:6px; image-rendering: pixelated; }
  #side { display:flex; flex-direction:column; gap:10px; }
  .card { background:#141622; border:1px solid #262837; border-radius:8px; padding:10px; }
  .title { font-weight:700; margin-bottom:6px; }
  #log { height:160px; overflow:auto; background:#0f1120; border:1px solid #2a2d42; border-radius:6px; padding:6px; font-size:13px; line-height:1.35; }
  .stat { display:inline-block; min-width:80px; }
  #controls { display:grid; grid-template-columns: repeat(3, 70px); grid-template-rows: repeat(3, 50px); gap:6px; justify-content:center; }
  #controls button, #toolbar button, .tilebtn { background:#1a1d2e; border:1px solid #2a2d42; color:#e6e6ea; border-radius:6px; }
  #controls button:active { transform: translateY(1px); }
  #toolbar { display:flex; gap:6px; flex-wrap:wrap; }
  .badge { background:#1f2340; border:1px solid #2d325a; border-radius:999px; padding:2px 8px; font-size:12px; }
  .palette { display:grid; grid-template-columns: repeat(7, 1fr); gap:6px; }
  .tilebtn{ height:28px; border-radius:6px; font-size:12px; }
  .tilebtn.selected { outline:2px solid #6aa6ff; }
  @media (max-width:960px){ #app{ grid-template-columns:1fr; } }
</style>
</head>
<body>
<div id="app">
  <div id="left">
    <canvas id="game" width="896" height="576"></canvas>
  </div>
  <div id="side">
    <div class="card">
      <div class="title">ğŸ® æ“ä½œï¼ˆv2 ä¿®æ­£ JSON åŒ¯å…¥éŒ¯èª¤ï¼‰</div>
      <div style="font-size:14px; line-height:1.45">
        ç§»å‹•ï¼šWASD / æ–¹å‘éµã€€|ã€€äº’å‹•ï¼šFã€€|ã€€é–‹é—œç·¨è¼¯å™¨ï¼šTabã€€|ã€€å­˜æª”ï¼šPã€€|ã€€è®€æª”ï¼šOã€€|ã€€èªªæ˜ï¼šH<br>
        <b>åŒ¯å…¥èªªæ˜ï¼š</b>è«‹å…ˆç”¨ã€ŒåŒ¯å‡º JSONã€ç”¢ç”Ÿ <code>map.json</code>ï¼Œå†ç”¨ã€ŒåŒ¯å…¥ JSONã€è¼‰å…¥ã€‚åŒæ™‚æ”¯æ´å®‰å…¨æª¢æŸ¥ï¼šè‹¥æª”æ¡ˆä¸æ˜¯ JSONï¼ˆä¾‹å¦‚ HTML ä»¥ &lt; é–‹é ­ï¼‰ï¼Œæœƒé¡¯ç¤ºå‹å–„éŒ¯èª¤ã€‚
      </div>
    </div>

    <div class="card">
      <div class="title">ğŸ§­ æ‰‹æ©ŸæŒ‰éˆ•</div>
      <div id="controls">
        <div></div><button id="btn-up">â–²</button><div></div>
        <button id="btn-left">â—€</button><button id="btn-interact">F</button><button id="btn-right">â–¶</button>
        <div></div><button id="btn-down">â–¼</button><div></div>
      </div>
      <div id="toolbar" style="margin-top:6px;">
        <button id="btn-edit">åˆ‡æ›ç·¨è¼¯(Tab)</button>
        <button id="btn-help">èªªæ˜(H)</button>
        <button id="btn-save">å­˜æª”(P)</button>
        <button id="btn-load">è®€æª”(O)</button>
        <button id="btn-reset">æ¸…ç©ºå­˜æª”</button>
      </div>
    </div>

    <div class="card">
      <div class="title">ğŸ“¦ ç‹€æ…‹</div>
      <div>
        <span class="stat">HPï¼š<span id="hp">5</span></span>
        <span class="stat">é‘°åŒ™ï¼š<span id="keys">0</span></span>
        <span class="stat">æ¨¡å¼ï¼š<span id="mode">æ¢ç´¢</span></span>
      </div>
    </div>

    <div class="card">
      <div class="title">ğŸ§° åœ°åœ–ç·¨è¼¯å™¨ï¼ˆTab é–‹é—œï¼‰</div>
      <div style="font-size:13px; opacity:.9">ç·¨è¼¯ï¼šé»ç•«å¸ƒç¹ªè£½ï¼›æ•¸å­— 0â€“6 å¿«é€Ÿé¸ç£šã€‚å³ä¸Šè§’é–€éœ€é‘°åŒ™ã€‚</div>
      <div class="palette" id="palette"></div>
      <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
        <button id="btn-export">åŒ¯å‡º JSON</button>
        <button id="btn-import">åŒ¯å…¥ JSON</button>
        <button id="btn-rand">éš¨æ©Ÿæˆ¿é–“</button>
        <button id="btn-template">è¼‰å…¥ç¤ºç¯„åœ°åœ–</button>
        <span class="badge" id="cursorInfo">ç•«ç­†ï¼šåœ°æ¿</span>
      </div>
    </div>

    <div class="card">
      <div class="title">ğŸ“ è¨Šæ¯</div>
      <div id="log"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const TILE = 32;
  const COLS = Math.floor(canvas.width / TILE);
  const ROWS = Math.floor(canvas.height / TILE);

  // Tile legend
  const TILES = {
    0: { name: 'åœ°æ¿', color: '#1b1f2d' },
    1: { name: 'ç‰†å£', color: '#2b3047' },
    2: { name: 'é‘°åŒ™', color: '#e7c84b' },
    3: { name: 'é–€(é–)', color: '#88553a' },
    4: { name: 'å¯¶ç®±', color: '#9b6d2e' },
    5: { name: 'æ°´åŸŸ', color: '#254b7a' },
    6: { name: 'NPC', color: '#6aa6ff' },
  };
  let editorTile = 0;

  function log(msg){
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML = `<div>[${time}] ${msg}</div>` + el.innerHTML;
  }

  // Map
  let map = Array.from({length: ROWS}, (_,y)=>
    Array.from({length: COLS}, (_,x)=> (x===0||y===0||x===COLS-1||y===ROWS-1)?1:0)
  );
  // Basic props
  map[5][6] = 2;    // key
  map[3][COLS-3] = 3; // door
  map[ROWS-4][4] = 4; // chest
  map[10][10] = 6;  // npc
  for(let y=8;y<12;y++){for(let x=2;x<12;x++){ if(Math.random()<0.12) map[y][x]=5; }}
  // A small inner room
  for(let x=14;x<22;x++){ map[6][x]=1; map[12][x]=1; }
  for(let y=6;y<13;y++){ map[y][14]=1; map[y][21]=1; }
  map[9][21]=0; // opening
  map[8][18]=4; // chest inside

  // Player
  let player = { x: 2, y: 2, hp: 5, keys: 0 };

  // Game state
  let inEditor = false;
  let showingHelp = true;

  // UI sync
  function syncUI(){
    document.getElementById('hp').textContent = player.hp;
    document.getElementById('keys').textContent = player.keys;
    document.getElementById('mode').textContent = inEditor ? 'ç·¨è¼¯' : 'æ¢ç´¢';
  }

  // Save/Load
  function saveGame(){
    try{
      const data = { map, player };
      localStorage.setItem('colab_game_save', JSON.stringify(data));
      log('å·²å­˜æª”ï¼ˆlocalStorageï¼‰');
    }catch(e){
      log('å­˜æª”å¤±æ•—ï¼š' + e.message);
    }
  }
  function loadGame(){
    try{
      const txt = localStorage.getItem('colab_game_save');
      if(!txt){ log('æ‰¾ä¸åˆ°å­˜æª”'); return; }
      const trimmed = txt.trim();
      if(!trimmed || (trimmed[0] !== '{' && trimmed[0] !== '[')){
        throw new Error('å­˜æª”å…§å®¹ä¸æ˜¯ JSONï¼ˆå¯èƒ½è¢«å¤–éƒ¨æ’å…¥çš„ HTMLï¼‰');
      }
      const data = JSON.parse(trimmed);
      if(data.map && data.player){
        map = data.map;
        player = data.player;
        log('å·²è¼‰å…¥å­˜æª”');
      } else {
        throw new Error('çµæ§‹ä¸ç¬¦ï¼ˆæ‡‰åŒ…å« map èˆ‡ playerï¼‰');
      }
    }catch(e){
      log('è®€æª”å¤±æ•—ï¼š' + e.message + 'ï¼ˆå¯æŒ‰ã€Œæ¸…ç©ºå­˜æª”ã€é‡ç½®ï¼‰');
    }
  }
  function resetSave(){
    try{
      localStorage.removeItem('colab_game_save');
      log('å·²æ¸…ç©ºå­˜æª”');
    }catch(e){
      log('æ¸…ç©ºå¤±æ•—ï¼š' + e.message);
    }
  }

  // Export/Import Map
  function exportMap(){
    try{
      const blob = new Blob([JSON.stringify({map}, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'map.json'; a.click();
      URL.revokeObjectURL(url);
      log('å·²åŒ¯å‡º map.json');
    }catch(e){
      log('åŒ¯å‡ºå¤±æ•—ï¼š' + e.message);
    }
  }
  function importMap(){
    const inp = document.createElement('input');
    inp.type = 'file'; inp.accept = '.json,application/json';
    inp.onchange = () => {
      const file = inp.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        try{
          const raw = reader.result;
          const trimmed = (raw||'').trim();
          if(!trimmed || (trimmed[0] !== '{' && trimmed[0] !== '[')){
            throw new Error('æ­¤æª”æ¡ˆä¸æ˜¯ JSONã€‚å¯èƒ½ä½ é¸åˆ°äº† HTML/ç¶²é æª”ï¼ˆä»¥ "<" é–‹é ­ï¼‰ã€‚è«‹ç”¨ã€ŒåŒ¯å‡º JSONã€ç”¢ç”Ÿ map.json å¾Œå†åŒ¯å…¥ã€‚');
          }
          const data = JSON.parse(trimmed);
          if(data.map && Array.isArray(data.map)){
            map = data.map;
            log('å·²åŒ¯å…¥åœ°åœ–');
          } else {
            throw new Error('æ ¼å¼ä¸æ­£ç¢ºï¼Œéœ€ç‚º { "map": [...] }');
          }
        } catch(e){
          log('åŒ¯å…¥å¤±æ•—ï¼š' + e.message);
        }
      };
      reader.readAsText(file);
    };
    inp.click();
  }

  // Template
  function loadTemplate(){
    const template = [];
    for(let y=0;y<ROWS;y++){
      const row = [];
      for(let x=0;x<COLS;x++){
        let v = (x===0||y===0||x===COLS-1||y===ROWS-1)?1:0;
        if(y>4 && y<ROWS-4 && x>4 && x<COLS-4 && (x+y)%7===0) v=1;
        row.push(v);
      }
      template.push(row);
    }
    template[2][2] = 2;
    template[3][COLS-3] = 3;
    template[ROWS-4][4] = 4;
    template[12][12] = 6;
    map = template;
    log('å·²è¼‰å…¥ç¤ºç¯„åœ°åœ–');
  }

  // Random room
  function randomRoom(){
    const rx = 2 + Math.floor(Math.random()*(COLS-10));
    const ry = 2 + Math.floor(Math.random()*(ROWS-8));
    const w = 6 + Math.floor(Math.random()*8);
    const h = 4 + Math.floor(Math.random()*6);
    for(let y=ry;y<ry+h;y++){
      for(let x=rx;x<rx+w;x++){
        if (x===rx||y===ry||x===rx+w-1||y===ry+h-1) map[y][x]=1; else map[y][x]=0;
      }
    }
    map[ry+Math.floor(h/2)][rx+w-1]=0;
    map[ry+1][rx+1]=4;
    map[ry+2][rx+2]=2;
    log('å·²ç”Ÿæˆéš¨æ©Ÿæˆ¿é–“');
  }

  function isWalkable(x,y){
    if(x<0||y<0||x>=COLS||y>=ROWS) return false;
    const t = map[y][x];
    return !(t===1 || t===3);
  }

  function drawTile(x,y,t){
    const T = TILES[t] ? t : 0;
    const info = TILES[T];
    ctx.fillStyle = info.color;
    ctx.fillRect(x*TILE, y*TILE, TILE, TILE);

    if(T===1){
      ctx.strokeStyle = '#3a3f58';
      ctx.setLineDash([8,8]);
      ctx.strokeRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4);
      ctx.setLineDash([]);
    } else if(T===2){
      ctx.fillStyle = '#2b2e45'; ctx.fillRect(x*TILE+8, y*TILE+12, TILE-16, 8);
      ctx.fillStyle = '#e7c84b'; ctx.fillRect(x*TILE+10, y*TILE+14, TILE-20, 4);
      ctx.beginPath(); ctx.arc(x*TILE+TILE-10, y*TILE+16, 5, 0, Math.PI*2); ctx.fill();
    } else if(T===3){
      ctx.fillStyle = '#5f3a28'; ctx.fillRect(x*TILE+4, y*TILE+4, TILE-8, TILE-8);
      ctx.fillStyle = '#2a170f'; ctx.fillRect(x*TILE+TILE/2-2, y*TILE+TILE/2-2, 4, 4);
    } else if(T===4){
      ctx.fillStyle = '#a77935'; ctx.fillRect(x*TILE+4, y*TILE+8, TILE-8, TILE-8);
      ctx.fillStyle = '#e7c84b'; ctx.fillRect(x*TILE+4, y*TILE+14, TILE-8, 2);
    } else if(T===5){
      for(let i=0;i<3;i++){ ctx.strokeStyle = '#3d78b8'; ctx.beginPath();
        ctx.arc(x*TILE+8+i*8, y*TILE+16, 6, Math.PI*0.2, Math.PI*1.2); ctx.stroke(); }
    } else if(T===6){
      ctx.fillStyle = '#cde0ff'; ctx.beginPath(); ctx.arc(x*TILE+16, y*TILE+16, 8, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#1b1f2d'; ctx.fillRect(x*TILE+10, y*TILE+20, 12, 6);
    }
  }

  function draw(){
    ctx.fillStyle = '#0e0f14'; ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++){ for(let x=0;x<COLS;x++){ drawTile(x,y,map[y][x]); } }
    ctx.fillStyle = '#f5a97f'; ctx.beginPath(); ctx.arc(player.x*TILE+TILE/2, player.y*TILE+TILE/2, TILE*0.35, 0, Math.PI*2); ctx.fill();
    if(showingHelp){
      ctx.fillStyle = 'rgba(0,0,0,.6)'; ctx.fillRect(20,20,canvas.width-40,120);
      ctx.fillStyle = '#e6e6ea'; ctx.font = '16px ui-sans-serif';
      ctx.fillText('æç¤ºï¼šWASD/æ–¹å‘éµç§»å‹•ï¼ŒFäº’å‹•ï¼ŒTabåˆ‡æ›ç·¨è¼¯ã€‚é–€éœ€è¦é‘°åŒ™ï¼Œå¯¶ç®±å¯æ‹¿ç‰©å“ï¼ŒNPCæœƒèªªè©±ã€‚',30,60);
      ctx.fillText('åŒ¯å…¥ JSON å¼·åŒ–ï¼šè‹¥æª”æ¡ˆä¸æ˜¯ JSONï¼ˆåƒ HTML ä»¥ "<" é–‹é ­ï¼‰æœƒé¡¯ç¤ºå‹å–„éŒ¯èª¤ã€‚',30,86);
      ctx.fillText('å­˜/è®€æª”ï¼šP / Oï¼›æ¸…ç©ºå­˜æª”æŒ‰éˆ•å¯é‡ç½® localStorageã€‚',30,112);
    }
  }

  function tryInteract(){
    const t = map[player.y][player.x];
    if(t===2){ player.keys += 1; map[player.y][player.x] = 0; log('ä½ æ’¿åˆ°äº†ä¸€æŠŠé‘°åŒ™'); }
    else if(t===4){ log('ä½ æ‰“é–‹å¯¶ç®±ï¼Œå¾—åˆ° +1 HP'); player.hp = Math.min(9, player.hp+1); map[player.y][player.x] = 0; }
    else {
      const dirs = [[0,-1],[1,0],[0,1],[-1,0]];
      for(const [dx,dy] of dirs){
        const x = player.x + dx, y = player.y + dy;
        if(x<0||y<0||x>=COLS||y>=ROWS) continue;
        const tt = map[y][x];
        if(tt===3){
          if(player.keys>0){ player.keys -= 1; map[y][x] = 0; log('ä½ ç”¨é‘°åŒ™æ‰“é–‹äº†é–€'); }
          else { log('é–€è¢«é–ä½äº†ï¼Œéœ€è¦é‘°åŒ™'); }
          break;
        } else if(tt===6){ log('NPCï¼šåœ°åœ–å¯ä»¥è‡ªç”±ç·¨è¼¯ï¼›æƒ³çœ‹ç¯„ä¾‹å°±æŒ‰ã€Œè¼‰å…¥ç¤ºç¯„åœ°åœ–ã€ã€‚'); break; }
      }
    }
    syncUI();
  }

  function move(dx,dy){
    if(inEditor) return;
    const nx = player.x + dx, ny = player.y + dy;
    if(!isWalkable(nx,ny)) return;
    player.x = nx; player.y = ny;
    if(map[ny][nx]===5 && Math.random() < 0.08){
      player.hp = Math.max(1, player.hp-1);
      log('ä½ åœ¨æ°´è£¡æ»‘äº†ä¸€è·¤ï¼ˆ-1 HPï¼‰');
      syncUI();
    }
  }

  function toggleEditor(){ inEditor = !inEditor; syncUI(); log(inEditor?'é€²å…¥ç·¨è¼¯æ¨¡å¼':'é›¢é–‹ç·¨è¼¯æ¨¡å¼'); }

  const keymap = {
    'ArrowUp':[0,-1],'KeyW':[0,-1],
    'ArrowDown':[0,1],'KeyS':[0,1],
    'ArrowLeft':[-1,0],'KeyA':[-1,0],
    'ArrowRight':[1,0],'KeyD':[1,0],
  };
  window.addEventListener('keydown', (e)=>{
    if(e.code in keymap){ e.preventDefault(); const [dx,dy]=keymap[e.code]; move(dx,dy); draw(); return; }
    if(e.code==='KeyF'){ tryInteract(); draw(); }
    if(e.code==='Tab'){ e.preventDefault(); toggleEditor(); draw(); }
    if(e.code==='KeyH'){ showingHelp=!showingHelp; draw(); }
    if(e.code==='KeyP'){ saveGame(); }
    if(e.code==='KeyO'){ loadGame(); draw(); }
    if(/^Digit[0-6]$/.test(e.code) && inEditor){ editorTile=parseInt(e.code.replace('Digit','')); updatePalette(); }
  });

  document.getElementById('btn-up').onclick = ()=>{ move(0,-1); draw(); };
  document.getElementById('btn-down').onclick = ()=>{ move(0,1); draw(); };
  document.getElementById('btn-left').onclick = ()=>{ move(-1,0); draw(); };
  document.getElementById('btn-right').onclick = ()=>{ move(1,0); draw(); };
  document.getElementById('btn-interact').onclick = ()=>{ tryInteract(); draw(); };
  document.getElementById('btn-edit').onclick = ()=>{ toggleEditor(); draw(); };
  document.getElementById('btn-help').onclick = ()=>{ showingHelp=!showingHelp; draw(); };
  document.getElementById('btn-save').onclick = ()=>{ saveGame(); };
  document.getElementById('btn-load').onclick = ()=>{ loadGame(); draw(); };
  document.getElementById('btn-reset').onclick = ()=>{ resetSave(); };
  document.getElementById('btn-export').onclick = ()=>{ exportMap(); };
  document.getElementById('btn-import').onclick = ()=>{ importMap(); };
  document.getElementById('btn-rand').onclick = ()=>{ randomRoom(); draw(); };
  document.getElementById('btn-template').onclick = ()=>{ loadTemplate(); draw(); };

  function updatePalette(){
    const pal = document.getElementById('palette'); pal.innerHTML = '';
    for(const [k,v] of Object.entries(TILES)){
      const b = document.createElement('button');
      b.className = 'tilebtn' + (parseInt(k)===editorTile? ' selected':'');
      b.textContent = `${k}:${v.name}`; b.style.background = v.color;
      b.onclick = ()=>{ editorTile=parseInt(k); updatePalette(); };
      pal.appendChild(b);
    }
    document.getElementById('cursorInfo').textContent = 'ç•«ç­†ï¼š' + TILES[editorTile].name;
  }

  function isWalkable(x,y){
    if(x<0||y<0||x>=COLS||y>=ROWS) return false;
    const t = map[y][x];
    return !(t===1 || t===3);
  }

  function fitCanvas(){
    const containerW = document.getElementById('left').clientWidth;
    const scale = Math.min(1, containerW / 896);
    canvas.style.transformOrigin = 'top left';
    canvas.style.transform = `scale(${scale})`;
  }
  window.addEventListener('resize', fitCanvas);

  updatePalette(); syncUI(); log('v2 å•Ÿå‹•ï¼šJSON åŒ¯å…¥å¼·åŒ– + æ¸…ç©ºå­˜æª”æŒ‰éˆ•'); draw(); fitCanvas();
})();
</script>
</body>
</html>
